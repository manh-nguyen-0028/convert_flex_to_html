"use strict";

var PING_SYNCHRONOUSLY  = false;
var PING_ASYNCHRONOUSLY = true;
  
var LongPollStatic = {
  TRANSPORT    :   "XMLHttpRequest",  
  PING_METHOD: PING_ASYNCHRONOUSLY,

  setRequiredHeader : function(xhr, clientID, transport) {
    xhr.setRequestHeader(RequestParameter.names.CLIENT_ID, clientID);
    xhr.setRequestHeader(RequestParameter.names.CLIENT_TRANSPORT, transport); 
  },

  appendToQueryString : function(uri, clientID, transport) {
    var firstSep = "?";
    if (uri.indexOf("?") > -1)
      firstSep = "&";
    uri += (firstSep + RequestParameter.names.CLIENT_ID + "=" + clientID);
    uri += ("&" + RequestParameter.names.CLIENT_TRANSPORT + "=" + transport); 

    return uri;
  }
};

var RequestAndBody = function(xhr, payload, label) {
  var request = xhr;
  var body = payload;  
  var name = (label === undefined ? "" : label);
  
  this.getRequest = function() {
    return request;
  };
  
  this.getBody = function() {
    return body;
  };
  
  this.getName = function() {
    return name;
  }
};

function LongPollRequest() {
  if (navigator.appName === "Microsoft Internet Explorer" && OraSocketGlobal.getIEVersion() < 10) {
    // To work, this one needs the CORS headers to be set, Access-Control-Allow-Origin, 
    //Access-Control-Allow-Headers, and Access-Control-Expose-Headers
    return new XDomainRequest();
  } else {
    return new XMLHttpRequest();
  }
};

/* 
 * Encoding is required when the browser does not support responseType = 'arraybuffer'
 * IE below versiom 9 (that must use an XDomainRequest), Safari are in this case.
 */
function encodingRequired() {
  return OraSocketGlobal.ENFORCE_ENCODING || 
         ((navigator.userAgent.indexOf("Safari") > -1 && navigator.userAgent.indexOf("Chrome") === -1) || // TODO Check version for Safari
          (navigator.userAgent.indexOf("Firefox") > -1) || 
          (OraSocketGlobal.getIEVersion() > -1 && OraSocketGlobal.getIEVersion() < OraSocketGlobal.ENCODE_FOR_IE_BELOW));
};

/*
 * LongPoll constructor
 * <br>
 * This should <b>NEVER</b> be invoked nor used by the client application.
 * <br>
 * It will be invoked by the WebSocket object when required or necessary.
 * @constructor
 * @param {string} clientId Client unique ID, generated by the server.
 * @param {string} serverURI The WebSocket application URI.
 * @param {boolean} encode Optional parameter, default false.
 * @returns {LongPoll}
 */
function LongPoll(clientId, serverURI, encode) {
  // The 4 ones to override
  this.onmessage        = function(mess) {};
  this.onopen           = function() {};
  this.onclose          = function() {};
  this.onerror          = function(error){}; 

  var ping;
  var self = this;
  var clientID = clientId;
  if (encode === undefined)
    encode = false;
  
  var connectionToBeClosed = false;
  var xhr;
  
  var startLongPoll = function() {
    xhr = new LongPollRequest(); // new XMLHttpRequest();
    
    var offsetInCurrentStream = 0;

    var manageDataStream = function() {
      var response = {};
      var payload; // = xhr.responseText;
      var xhrResponse;
      var goodToParse = true;
      try {
        // May contain several frames
        if (!encodingRequired())
          xhrResponse = xhr.response; 
        else
          xhrResponse = xhr.responseText;
       
        if ((xhr.getResponseHeader !== undefined && 
            (xhr.getResponseHeader(RequestParameter.names.CHAR_ENCODED) === "yes" ||
             xhr.getResponseHeader(RequestParameter.names.CHAR_ENCODED) === "base16")) ||
            encodingRequired()) {
          if (xhrResponse !== undefined && xhrResponse !== null) {
            if (OraSocketGlobal.debugLevel > 10) {  
              console.debug("BaseXX encoded [" + xhrResponse + "]");
              console.debug("Encoded length:" + xhrResponse.length);
            }
            xhrResponse = OraSocketGlobal.baseXXdecode(xhrResponse); // atob(xhrResponse);
          }
        }
        
        if (xhrResponse === undefined || xhrResponse === null)
          goodToParse = false;
      } catch (err) {
//        if (OraSocketGlobal.debugLevel > 7)
//          console.debug("Error: readyState = " + OraSocketGlobal.GnlUtils.decodeReadyState(xhr.readyState) + " and status = " + OraSocketGlobal.GnlUtils.decodeStatus(xhr.status) + ", but xhr.response not available...");
        goodToParse = false;
      }

      if (goodToParse) {
//      console.debug("xhrResponse is a " + typeof(xhrResponse));
        var framedResponse;
        var uInt8Array;
        var frameIndexInPayload = offsetInCurrentStream; // Begin where we left it the revious time
        if (typeof(xhrResponse) === "string") {  
          framedResponse = OraSocketGlobal.FramingUtils.string2ArrayBuffer(xhrResponse);
          uInt8Array = framedResponse;
        } else {
          framedResponse = xhrResponse;
          uInt8Array = new Uint8Array(framedResponse);
        }
        // console.debug("Content-Type: " + xhr.getResponseHeader("content-type"));
        // console.debug("Framed response:" + uInt8Array.length + " byte(s)");          
        if (OraSocketGlobal.debugLevel > 10) {
          var all = "";
          for (var i=0; i<uInt8Array.length; i++) {
            all += ("[" + OraSocketGlobal.FramingUtils.formatHexa(uInt8Array[i].toString(16), 2) + "] ");
          }
          console.debug("All the frames (" + uInt8Array.length + ") :" + all);
        }
        var enoughData = false;
        do {
          try {
            enoughData = ((frameIndexInPayload + OraSocketGlobal.FramingUtils.getFrameLength(uInt8Array, frameIndexInPayload)) <= uInt8Array.length);
          } catch (err) {
            enoughData = false;
          }
          if (enoughData) {
            if (OraSocketGlobal.debugLevel > 5) {
              console.debug("From the backend Channel:");
              try { console.debug(". FrameIndex:" + frameIndexInPayload); } catch (err) {}
              try { console.debug(". Frame Head:" + OraSocketGlobal.FramingUtils.dumpHeader(uInt8Array, frameIndexInPayload)); } catch (err) {}
              try { console.debug(". Frame length:" + OraSocketGlobal.FramingUtils.getFrameLength(uInt8Array, frameIndexInPayload) + " byte(s)"); } catch (err) {}
              try { console.debug(". Fin : " + OraSocketGlobal.FramingUtils.getFin(uInt8Array, frameIndexInPayload)); } catch (err) {}
              try { console.debug(". OpCode : " + OraSocketGlobal.FramingUtils.readableOpCode(OraSocketGlobal.FramingUtils.getOpCode(uInt8Array, frameIndexInPayload))); } catch (err) {}
              try { console.debug(". Payload length : " + OraSocketGlobal.FramingUtils.getPayloadLength(uInt8Array, frameIndexInPayload)); } catch (err) {}
              try { console.debug(". Mask [" + (OraSocketGlobal.FramingUtils.getMask(uInt8Array, frameIndexInPayload) === 1 ? OraSocketGlobal.FramingUtils.displayMask(OraSocketGlobal.FramingUtils.getMaskingKey(uInt8Array, frameIndexInPayload)):"") + "]"); } catch (err) {}
            }
            if (OraSocketGlobal.debugLevel > 10) {
              var all = "";
              var fl = OraSocketGlobal.FramingUtils.getFrameLength(uInt8Array, frameIndexInPayload);
              for (var i=frameIndexInPayload; i<frameIndexInPayload + fl; i++) {
                all += ("[" + OraSocketGlobal.FramingUtils.formatHexa(uInt8Array[i].toString(16), 2) + "] ");
              }
              console.debug("Framed (" + fl + ") :" + all);
            }

            payload = "";
            var maskingKey = [0x00, 0x00, 0x00, 0x00]; // identity, default.
            if (OraSocketGlobal.FramingUtils.getMask(uInt8Array, frameIndexInPayload) === 1)
              maskingKey = OraSocketGlobal.FramingUtils.getMaskingKey(uInt8Array, frameIndexInPayload);          

            var payloadOffset = OraSocketGlobal.FramingUtils.getPayloadOffset(uInt8Array, frameIndexInPayload);
            var origin = frameIndexInPayload + payloadOffset; 
            var end    = origin + OraSocketGlobal.FramingUtils.getPayloadLength(uInt8Array, frameIndexInPayload);
            for (var i=origin; i<end; i++) {
              if (OraSocketGlobal.debugLevel > 30 && i < (payloadOffset + 50)) {
                var decoded = uInt8Array[i] ^ maskingKey[(i - origin) % 4];
                console.debug("Appending char [" + OraSocketGlobal.FramingUtils.formatHexa(uInt8Array[i].toString(16), 2) +
                     "] => [" + OraSocketGlobal.FramingUtils.formatHexa(decoded.toString(16), 2) + "]");
              }
              // Decode
              payload += String.fromCharCode(uInt8Array[i] ^ maskingKey[(i - origin) % 4]); // with de-masking. 4: key length in bytes.
            }   
            if (OraSocketGlobal.debugLevel > 5) {
              // 50 bytes of data
              var hexa = "";
              for (var i=origin; i<Math.min(origin + 50, payload.length); i++) {
                hexa += ("0x" + OraSocketGlobal.FramingUtils.formatHexa(payload.charCodeAt(i).toString(16), 2) + " ");
              }
              console.debug("After de-masking:");
              console.debug(hexa);
            }
            if (OraSocketGlobal.debugLevel > 5 && 
                OraSocketGlobal.FramingUtils.getOpCode(uInt8Array, frameIndexInPayload) === OraSocketGlobal.FramingUtils.UTF_8_DATA)              
              console.debug("UTF_8_DATA (unmasked):" + payload);

            if (payload.length > 0) {
              try {
//              var dummy = JSON.parse(payload);                
                response = payload; // JSON.parse(payload); // "string"
                if (OraSocketGlobal.FramingUtils.getOpCode(uInt8Array, frameIndexInPayload) === OraSocketGlobal.FramingUtils.UTF_8_DATA)
                  self.onmessage( { data: response } ); // TODO Other members?
                else
                  self.onmessage(response);
              } catch (err) {
                response = payload; // Binary?
                self.onmessage(response);
              }
        //    console.debug("From Long Polling:" + response.toString());
              /*
               * Broadcast to the client
               */
//            self.onmessage( { data: response } ); // TODO Other members?
            } else {
              if (OraSocketGlobal.FramingUtils.getOpCode(uInt8Array, frameIndexInPayload) === OraSocketGlobal.FramingUtils.PONG || 
                  OraSocketGlobal.FramingUtils.getOpCode(uInt8Array, frameIndexInPayload) === OraSocketGlobal.FramingUtils.PING || 
                  OraSocketGlobal.FramingUtils.getOpCode(uInt8Array, frameIndexInPayload) === OraSocketGlobal.FramingUtils.TERMINATES_CONNECTION)
                response = {};
            }
            
            frameIndexInPayload += OraSocketGlobal.FramingUtils.getFrameLength(uInt8Array, frameIndexInPayload);
            offsetInCurrentStream = frameIndexInPayload;
          }
        } while (enoughData && frameIndexInPayload < uInt8Array.length);
      }
    };
    
    var updateProgress = function(event) {
//      var mess = "Transfer progressing... ";
//      if (event.lengthComputable)
//        try { mess += (event.total + "/" + event.totalSize); } catch (err) {}
//      console.debug(mess);
      // Chrome issue with arraybuffer: https://code.google.com/p/chromium/issues/detail?id=92773
      try {
        var response;
        if (!encodingRequired())
          response = xhr.response; 
        else
          response = xhr.responseText;
        if (response !== undefined) {
//        console.debug("Response is " + response.length + " byte(s) long.");
          manageDataStream();
        }
      } catch (err) {
        console.debug("Transfer Progressing, err:" + JSON.stringify(err));
      }
    };
    
    var transferComplete = function(event) {
//      console.debug("Transfer completed");
      try {
        if (xhr.getAllResponseHeaders && OraSocketGlobal.debugLevel > 10) {
          var headers = xhr.getAllResponseHeaders();
          console.debug("All headers:\n" + headers);
        }
        var response;
        if (!encodingRequired())
          response = xhr.response; 
        else
          response = xhr.responseText;
        if (response !== undefined) {
          manageDataStream();
        }
        offsetInCurrentStream = 0; // Reset
        if (!connectionToBeClosed) {
          if (OraSocketGlobal.debugLevel > 5)
            console.debug("[" + (new Date()).format("Y-M-d H:i:s._ Z") + 
              "] Client (transferComplete) [" + clientID + "] restarting long poll after receiving a message.");
          startLongPoll(clientId);         
        } else {
          if (OraSocketGlobal.debugLevel > 5)
            console.debug("[" + (new Date()).format("Y-M-d H:i:s._ Z") + "] Leaving.");
        }
      } catch (err) {
        console.debug("Transfer Completed, err:" + JSON.stringify(err));
      }
    };

    var transferFailed = function(event) {
      var errmess = "An error occurred while transferring the data";
      console.debug(errmess + ":" + JSON.stringify(event));
      self.onerror({ err: errmess });
    };
 
    var transferCanceled = function(event) {
      console.debug("The transfer has been canceled by the user.");
    };

    xhr.onprogress  = updateProgress;
    // xhr.onloadend   = function() { console.debug('** Load Ends'); };
    // xhr.onloadstart = function() { console.debug('** Load Starts'); };
//  xhr.onabort     = transferCanceled;
    xhr.onload      = transferComplete;
    xhr.ontimeout   = function() { console.debug('** XHR Timed out'); };
    xhr.onerror     = transferFailed;

    // xhr.addEventListener("progress", updateProgress,   false);
    // xhr.addEventListener("load",     transferComplete, false);
    // xhr.addEventListener("error",    transferFailed,   false);
    // xhr.addEventListener("abort",    transferCanceled, false);
    if (!encodingRequired()) {
      try { 
        xhr.responseType = 'arraybuffer'; 
//      console.debug('responseType set to arraybuffer');
      } catch (err) {
        console.debug('Error setting responseType:' + JSON.stringify(err));
      } 
    }
    
    // WARNING: a synchronous request on "localhost" would NEVER come back if the server is down...
//    serverURI = serverURI.replace("localhost", "127.0.0.1");
    if (xhr.setRequestHeader) {
      xhr.open("POST", serverURI, true); // true: async. MUST be true if responseType is set on Chrome.
      try {
        LongPollStatic.setRequiredHeader(xhr, clientID, LongPollStatic.TRANSPORT); 
        xhr.setRequestHeader(RequestParameter.names.CLIENT_OPERATION, WSOperation.WAIT_FOR_INPUT); 
        xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // text/plain; charset=utf-8');
        xhr.setRequestHeader('cache-control', 'no-cache');
        xhr.setRequestHeader('pragma', 'no-cache');
        xhr.setRequestHeader(RequestParameter.names.REQUIRE_ENCODING, (encodingRequired() ? "yes":"no"));
    //  try { xhr.setRequestHeader('Content-Length', '0'); } catch (err) {}
      } catch (err) {
        console.debug("Cannot set headers on this request:" + JSON.stringify(err));
        xhr.abort();
        var serverURI$ = LongPollStatic.appendToQueryString(serverURI, clientID, LongPollStatic.TRANSPORT);
        serverURI$ += "&" + RequestParameter.names.CLIENT_OPERATION + "=" + WSOperation.WAIT_FOR_INPUT; 
        serverURI$ += ("&" + RequestParameter.names.UNIQUE_REQ_ID + "=" + Math.random().toString()); // to avoid request caching
        serverURI$ += ('&' + RequestParameter.names.REQUIRE_ENCODING + '=' + (encodingRequired() ? "yes":"no"));
        serverURI$ += ('&' + RequestParameter.names.CORS_REQUIRED + '=' + "yes");
        if (OraSocketGlobal.debugLevel > 10)        
          console.debug("Request becomes:" + serverURI$);
        xhr.open("POST", serverURI$, true); // true: async
      }
    } else {
      // IE & XDomainRequest
      var serverURI$ = LongPollStatic.appendToQueryString(serverURI, clientID, LongPollStatic.TRANSPORT);
      serverURI$ += "&" + RequestParameter.names.CLIENT_OPERATION + "=" + WSOperation.WAIT_FOR_INPUT; 
      serverURI$ += ("&" + RequestParameter.names.UNIQUE_REQ_ID + "=" + Math.random().toString());  // to avoid request caching
      serverURI$ += ('&' + RequestParameter.names.REQUIRE_ENCODING + '=' + (encodingRequired() ? "yes":"no"));
      serverURI$ += ('&' + RequestParameter.names.CORS_REQUIRED + '=' + "yes");
      if (OraSocketGlobal.debugLevel > 10)        
        console.debug("Request becomes:" + serverURI$);
      xhr.open("POST", serverURI$, true); // true: async
    }
    
    xhr.send();

    // Ping
    if (OraSocketGlobal.PING_ENABLED) {
      var startPing = function() {
//      console.debug("[" + (new Date()).format("Y-M-d H:i:s._ Z") + "] **** startPing invoked");
        try {
          var pingXhr = new XMLHttpRequest();
          
          var errorSent = false;
          pingXhr.onreadystatechange = function() {
//          console.debug("State :" + pingXhr.readyState + ", status:" + pingXhr.status);         
            try {
              var mess = "State :" + pingXhr.readyState;
              mess += ", status:" + pingXhr.status;
              if (pingXhr.status !== OraSocketGlobal.HTTP_OK && !errorSent) {
                errorSent = true;
                self.onerror({ err: "Connection Lost (Ping, XHR) - HTTP " + pingXhr.status});
                if (OraSocketGlobal.debugLevel > 1) {
                  console.debug("Ping failed - 1: Connection lost (" + 
                       OraSocketGlobal.GnlUtils.decodeReadyState(pingXhr.readyState) + ")");    
                }            
                console.debug("PingXHR: " + mess);

                if (ping !== undefined)
                  clearTimeout(ping);
                pingXhr.abort();
                pingXhr.open("POST", serverURI, LongPollStatic.PING_METHOD); // Required to complete the abort. No comment.
              }
            } catch (err) { }
            
            if (pingXhr.readyState === OraSocketGlobal.XHR_SOME_RESPONSE_BODY_RECEIVED || 
                pingXhr.readyState === OraSocketGlobal.XHR_REQUEST_COMPLETED) {
//            console.debug("Status:" + pingXhr.status);
              try {
                if (!errorSent && pingXhr.status !== undefined && 
                    (pingXhr.status === OraSocketGlobal.ERROR_INTERNET_CANNOT_CONNECT ||
                     pingXhr.status === OraSocketGlobal.ERROR_INTERNET_TIMEOUT ||
                     pingXhr.status === OraSocketGlobal.ERROR_INTERNET_NAME_NOT_RESOLVED ||
                     pingXhr.status === OraSocketGlobal.ERROR_INTERNET_CONNECTION_ABORTED ||
                     pingXhr.status === OraSocketGlobal.ERROR_INTERNET_CONNECTION_RESET ||
                     pingXhr.status === OraSocketGlobal.ERROR_HTTP_INVALID_SERVER_RESPONSE ||
                     pingXhr.status === OraSocketGlobal.HTTP_NO_DATA)) {
                  if (ping !== undefined)
                    clearTimeout(ping);
                  pingXhr.abort();
                  pingXhr.open("POST", serverURI, LongPollStatic.PING_METHOD); // Required to complete the abort. No comment.
                  self.onerror({ err: "Connection Lost (Ping, XHR) - 1"});

                  if (OraSocketGlobal.debugLevel > 1)
                    console.debug("Ping failed - 1: Connection lost (" + 
                        OraSocketGlobal.GnlUtils.decodeReadyState(pingXhr.readyState) +  ")");
                }
              } catch (err) {
                console.debug("error evaluating the status.");
              }
              if (pingXhr.readyState === OraSocketGlobal.XHR_REQUEST_COMPLETED && 
                  pingXhr.status === OraSocketGlobal.HTTP_OK) {
                // I something, should be a pong
                var framedResponse, uInt8Array;
                if (!encodingRequired()) {
                  framedResponse = pingXhr.response; 
                  if (framedResponse !== null)
                    uInt8Array = new Uint8Array(framedResponse);        
                } else {
                  framedResponse = pingXhr.responseText;
                  if (framedResponse !== null)
                    uInt8Array = framedResponse;
                }
                
                if (framedResponse !== null && (pingXhr.getResponseHeader(RequestParameter.names.CHAR_ENCODED) === "yes" || 
                                                pingXhr.getResponseHeader(RequestParameter.names.CHAR_ENCODED) === "base16")) {
                  uInt8Array = OraSocketGlobal.baseXXdecode(framedResponse); 
                }
                if (uInt8Array !== null && uInt8Array !== undefined && uInt8Array.length !== 0 && OraSocketGlobal.debugLevel > 10) {
                  console.debug("Framed response:" + uInt8Array.length + " byte(s)" + 
                              ", Fin : " + OraSocketGlobal.FramingUtils.getFin(uInt8Array) +
                              ", OpCode : " + OraSocketGlobal.FramingUtils.readableOpCode(OraSocketGlobal.FramingUtils.getOpCode(uInt8Array)) +
                              ", Payload length : " + OraSocketGlobal.FramingUtils.getPayloadLength(uInt8Array));
                }
                if (framedResponse !== null && uInt8Array.length !== 0) {
                  if (OraSocketGlobal.FramingUtils.getOpCode(uInt8Array) === OraSocketGlobal.FramingUtils.PONG)
                    console.debug("The PING xhr received a PONG.")
                  if (OraSocketGlobal.FramingUtils.getPayloadLength(uInt8Array) !== 0 && 
                      OraSocketGlobal.FramingUtils.getOpCode(uInt8Array) === OraSocketGlobal.FramingUtils.PONG)
                    console.debug("Payload size should be 0 for a pong.");
                  else if (OraSocketGlobal.FramingUtils.getOpCode(uInt8Array) !== OraSocketGlobal.FramingUtils.PONG)
                    console.debug("OpCode is [" + 
                       OraSocketGlobal.FramingUtils.readableOpCode(OraSocketGlobal.FramingUtils.getOpCode(uInt8Array)) + 
                       "] after a PING...");
                }
//              else
//                console.debug("Got no reply to my ping...");
                // Restart ping
                ping = window.setTimeout(function() { startPing(); }, OraSocketGlobal.PING_INTERVAL);
              }
            }
          };
          pingXhr.open("POST", serverURI, LongPollStatic.PING_METHOD); 
//        pingXhr.overrideMimeType("text/plain; charset=x-user-defined");
          if (!encodingRequired()) {
            try { pingXhr.responseType = 'arraybuffer'; } catch (err) {} // Chrome does not like this when called Synchronously...          
          }
          LongPollStatic.setRequiredHeader(pingXhr, clientID, LongPollStatic.TRANSPORT); 
          pingXhr.setRequestHeader(RequestParameter.names.CLIENT_OPERATION,  WSOperation.SEND_MESSAGE);
          pingXhr.setRequestHeader('Content-Type', 'application/octet-stream'); // text/plain; charset=utf-8');
          var framed = OraSocketGlobal.FramingUtils.frameMessage("", OraSocketGlobal.FramingUtils.PING, 0); // 0 means no mask
          var binPayload = OraSocketGlobal.FramingUtils.binaryString(framed);
          if (encodingRequired()) {
            // Base64 encode the framed payload  
            binPayload = OraSocketGlobal.baseXXencode(framed);
            pingXhr.setRequestHeader(RequestParameter.names.REQUIRE_ENCODING, "yes"); 
          }
//          try { 
//            pingXhr.send(binPayload);
//          } catch (err) {
//            console.warn("A Message when pinging:" + JSON.stringify(err));
//            // See https://github.com/weixiyen/jquery-filedrop/issues/85
//          }
          enqueueForProcessing(new RequestAndBody(pingXhr, binPayload, "PING"));
//        console.debug(LongPollStatic.TRANSPORT + " ...ping " + framed.length);
        } catch (err) {
          pingXhr.abort();
          pingXhr.open("POST", serverURI, LongPollStatic.PING_METHOD); // Required to complete the abort. No comment.
          if (ping !== undefined)
            clearTimeout(ping);
          self.onerror({err: "Connection Lost (Ping, XHR) - 2"});

          if (OraSocketGlobal.debugLevel > 2) {
            console.debug("Ping failed: Connection lost - 2");
            console.debug("Ping failed - 2: Connection lost (" + OraSocketGlobal.GnlUtils.decodeReadyState(pingXhr.readyState) + ")");
          }
        }
      }; 
      if (ping === undefined) {
	// Only if not pinging already.
//      console.debug("Starting to ping the server every " + OraSocketGlobal.PING_INTERVAL + " ms.");
//      startPing(); 
        ping = window.setTimeout(function() { startPing(); }, 0);
      }
    }
  };

  var processingRequestQueue = false;
  var processingDelay = 0; // Increase this value to see actual queuing happen...

  var postHTTPRequest = function(payload) {
    var xhr = new XMLHttpRequest();
    
    // Temp
//    var uri = serverURI;
//    var firstSep = "?";
//    if (uri.indexOf("?") > -1)
//      firstSep = "&";
//    uri += (firstSep + RequestParameter.names.CLIENT_OPERATION + "=" + WSOperation.SEND_MESSAGE);

    xhr.open("POST", serverURI, true); // true:Async, false:Sync. We dont care about the response
    if (!encodingRequired()) {
      try { xhr.responseType = 'arraybuffer'; } catch (err) {} 
    }
    LongPollStatic.setRequiredHeader(xhr, clientID, LongPollStatic.TRANSPORT); 
    xhr.setRequestHeader(RequestParameter.names.CLIENT_OPERATION, WSOperation.SEND_MESSAGE); 
    //  xhr.setRequestHeader('Content-Type', 'text/plain; charset=utf-8');
    xhr.setRequestHeader('Content-Type', 'application/octet-stream');
    var framed = OraSocketGlobal.FramingUtils.frameMessage(payload, OraSocketGlobal.FramingUtils.UTF_8_DATA);  // Frame the payload
//  try { xhr.setRequestHeader('Content-Length', framed.length.toString()); } catch (err) {}
    xhr.setRequestHeader('cache-control', 'no-cache');
    xhr.setRequestHeader('pragma', 'no-cache');
    var binPayload = OraSocketGlobal.FramingUtils.binaryString(framed);
    if (encodingRequired()) {
      // Base64 encode the framed payload    
      binPayload = OraSocketGlobal.baseXXencode(framed);
      xhr.setRequestHeader(RequestParameter.names.REQUIRE_ENCODING, "yes"); 
    }
    // Queue the messages here
    enqueueForProcessing(new RequestAndBody(xhr, binPayload, "APP_REQUEST"));
//  xhr.send(binPayload);
  };
  
  var enqueueForProcessing = function(rnb) {
    OraSocketGlobal.requestQueue.enqueue(rnb);
    if (OraSocketGlobal.debugLevel > 10)
      console.debug("[" + (new Date()).format("Y-M-d H:i:s._ Z") + "] **** Request " + 
          (rnb.getName().length > 0? "[" +rnb.getName() + "] " : "") + "has been enqueued. " + 
          OraSocketGlobal.requestQueue.getSize() + " to go.");
    setTimeout( function() { 
      if (!processingRequestQueue)
        processRequestQueue(); 
      else if (OraSocketGlobal.debugLevel > 10)
        console.debug("Alreday your the case, please wait..., " + OraSocketGlobal.requestQueue.getSize() + " request(s) in the queue.")
    }, processingDelay);
  };
  
  var processRequestQueue = function() {
    if (!OraSocketGlobal.requestQueue.isEmpty()) {
      processingRequestQueue = true;
      var request = OraSocketGlobal.requestQueue.dequeue(); // Next!
      var xhr        = request.getRequest();
      var binPayload = request.getBody();
//    xhr.onreadystatechange = function() {}; 
      var executeOnLoad = xhr.onload;         // This one seems never to be defined...
      xhr.onload = function(event) {
        if (xhr.readyState !== OraSocketGlobal.XHR_REQUEST_COMPLETED)
          console.debug("~~~ In processRequestQueue, wierd xhr.readyState:" + xhr.readyState);
        
        if (executeOnLoad)
          executeOnLoad(event); // What was previously set. 
        if (OraSocketGlobal.debugLevel > 10)        
          console.debug("[" + (new Date()).format("Y-M-d H:i:s._ Z") + "] **** Request " + 
               (request.getName().length > 0? "[" +request.getName() + "] " : "") + 
               "has been processed. " + OraSocketGlobal.requestQueue.getSize() + " left.");                
        // Next in queue
        if (!OraSocketGlobal.requestQueue.isEmpty()) {
          setTimeout( function() { processRequestQueue(); }, processingDelay);
        } else {
          if (OraSocketGlobal.debugLevel > 10)        
            console.debug("**** Queue empty. Done.");
          processingRequestQueue = false;
        }
      };      
      try { 
        xhr.send(binPayload); 
      } catch (err) {
        console.warn("A Message when dequeuing:" + JSON.stringify(err));
        // See https://github.com/weixiyen/jquery-filedrop/issues/85
      }
    }
    else {
      processingRequestQueue = false;
    }
  };

  var closeServerConnection = function() {
    console.debug("Terminate request");
    connectionToBeClosed = true;
    var xhrClose = new XMLHttpRequest();
    xhrClose.onreadystatechange = function() {};
    xhrClose.open("POST", serverURI, true); // true:Async, false:Sync. We dont care about the response
    if (!encodingRequired()) {
      try { xhrClose.responseType = 'arraybuffer'; } catch (err) {}
    }
    LongPollStatic.setRequiredHeader(xhrClose, clientID, LongPollStatic.TRANSPORT); 
//  xhrClose.setRequestHeader(RequestParameter.names.CLIENT_OPERATION, WSOperation.CLOSE_CONNECTION); 
//  xhrClose.setRequestHeader('Content-Type', 'text/plain; charset=utf-8');
    xhrClose.setRequestHeader('Content-Type', 'application/octet-stream');
    xhrClose.setRequestHeader(RequestParameter.names.CLIENT_OPERATION,  WSOperation.SEND_MESSAGE);
    var framed = OraSocketGlobal.FramingUtils.frameMessage("", OraSocketGlobal.FramingUtils.TERMINATES_CONNECTION);
    var binPayload = OraSocketGlobal.FramingUtils.binaryString(framed);
    if (encodingRequired()) {
      // Base64 encode the framed payload  
      binPayload = OraSocketGlobal.baseXXencode(framed);
      xhrClose.setRequestHeader(RequestParameter.names.REQUIRE_ENCODING, "yes"); 
    }
    xhrClose.send(binPayload);
  };

  this.send = function(msg) {
    if (!msg) {
      return;
    }
    postHTTPRequest(msg);
  };

  this.close = function() {
    clearInterval(ping);
    closeServerConnection();
    this.onclose();
  };
  
  this.quit = function() {
    this.close();
  };

  // Initial long poll
  startLongPoll();
};

